### 1	目的

 该规范的目的是在《FPGA设计规范》下，对采用VerilogHDL语言编写可编程逻辑器件设计的代码进行规范，提高代码的整洁度、可读性、可继承性、可维护修改性，便于跟踪、分析、调试，便于文档的整理，便于交流合作，因此在研发部内统一代码风格有很重要的现实意义。
基于未来HDL设计有全面转向System Verilog的趋势，该规范明确规定网络产出线研发部的逻辑新设计优先采用Verilog HDL语言进行编写，但为了FPGA设计版本的维护及混合设计和混合仿真的方便，本文所针对硬件描述语言以Verilog为基准。
2	适用范围
本规范适用于烽火通信科技股份有限公司网络产出线研发部所有采用Verilog HDL语言进行开发活动的专项、项目组及个人。对于使用商业代码或遇特殊情况无法适用本规范，需向三级部门经理报批确认。
3	规范正文
3.1	命名规范
采用有意义的、能反映对象特征、作用和性质的单词命名标识符，以增强程序的可读性。
3.1.1	【规定】顶层源代码的端口名称与FPGA端口说明保持一致
顶层源代码的端口名称和《FPGA端口说明》文档中FPGA的管脚信号名称保持一致。
3.1.2	【规定】子模块的端口名称按照设计文档命名
子模块的端口名称按照《概要设计》或者《模块设计任务书》文档中已定义的端口名称来命名，或按照已有的IP Core子模块的端口名称来命名。
3.1.3	【规定】信号命名的后缀规则
后缀信号命名采用下面的格式：
<signal_prefix>_<signal name> [_async|_sync][_ns][_l][_z][_n][_nc][_test]
	_async ：异步信号；	例如：异步复位信号表示为 rst_dsp_async ； 
	_sync ：同步信号（可选）；	例如：同步复位信号表示为 rst_dsp_sync ； 
	_ns ：状态机下一状态；	例如：状态机中的等待状态表示为 wait_ns ； 
	_l ：锁存器输出；	例如：锁存器输出的保持信号表示为 hold_l ； 
	_z ：高阻信号；	例如：三态总线的高阻信号表示为 tpi_bus_z ； 
	_n ：低有效信号；	例如：低有效的复位信号表示为 rst_n ； 
	_nc ：不连信号；	例如：不连的备用信号表示为 tp_nc ；
	_pn：多周期路径第n 个周期使用的信号；例如：使用后缀data_3n；用单变量数组延时不在此列；
	_test ：测试信号；	例如：测试信号表示为 clk_out_test ； 
3.1.4	【规定】区分大小写
所有的信号（signal）、变量（variable）以及模块（module）的名字都用小写字母，常量名（参数parameter和宏macro）用大写字母。不要依赖大小写给标识符增加语义。
说明：这样做是为了和业界的习惯保持一致，避免了在大小写敏感的工具中可能会遇到的问题（verilog 语言是大小写敏感），同时也可以很容易地从代码中辨认出参数（parameter）。特注：信号名一律小写，参数用大写，例化的源语模块默认为大写。
示例：
不好的 									好的
parameter width = 16；				    parameter WIDTH = 16；
input [width-1 : 0] DataIn；			 	input [WIDTH-1 : 0] data_in；
3.1.5	【规定】模块命名
1．在系统设计阶段应该为顶层文件和每个一级模块进行命名。
2．顶层文件命名方法是：单盘全称或者功能名称缩写（共版情况以归档SVN的版本命名）+_top。
3．一级模块命名的方法是：将模块英文名称的各个单词首字母组合起来，形成3 到5 个字符的缩写。若模块的英文名只有一个单词，可取该单词的前3 个字母。
一级模块定义：在顶层文件中例化的模块。
4．对于二级以下模块（含二级模块）命名方法是：一级模块名字_+模块功能缩写。
示例：
单盘scun1项目的顶层文件命名为scun1top；
一级模块Arithmatic Logical Unit 命名为alu；
一级模块Data Memory Interface 命名为dmi；
一级模块Decoder 命名为dec；
一级模块CPU 里面的二级模块，功能是完成flash 的控制功能，命名为cpu_flash_ctl。
3.1.6	【规定】信号命名
1．信号的命名由几个单词连接而成，用下划线（‘_’）来分隔名字中的不同部分；
2．尽量使用缩写，缩写要求能基本表明本单词的含义，单词除常用的缩写方法外（如clock->clk，write->wr，read->rd 等，常用缩写见附表1），一律取该单词的前3—4 个字母（如frequency->freq，variable->var 等）；
3．信号名长度不要太长，原则上不超过32 个字符；
4. 不能用‘reg’作为最后的后缀名，因为综合工具会给寄存器加上reg，如果命名中使用
了reg 作为后缀，则会扰乱综合网表的可读性。
常用单词的缩写方法见附录1。
说明：这样可以增强代码的可读性，并能避免标识符过于冗长。
示例：
不好的 									好的
wire [9:0] addresscontrolenable； 		wire [9:0] addr_ctl_en；
reg [15:0] I，q；					    	reg [15:0] datai；
								        	reg [15:0] dataq；
3.1.7	【规定】避免关键字
在RTL 源码的设计中任何元素包括端口、信号、变量、函数、任务、模块等的命名都不能取Verilog 和VHDL 语言中的关键字。
示例：always、while、case等。
3.1.8	【规定】文件名命名
文件名要和模块名相同，在一个文件中只用一个模块，在不同的层级上尽量使用统一的信号名，这样容易跟踪信号，网表调试也容易。
3.1.9	【规定】时钟和复位信号命名
对于时钟信号使用前缀clk_*（*表示相应后缀），并使用有含义的缩写构成时钟信号，对于同一个时钟信号，在所有的模块中名字保持一致。
对于复位信号使用前缀rst_*（同上），并使用有含义的缩写构成复位信号，对于同一个复位信号，在所有的模块中名字保持一致。
示例：clk_lbus_33m，clk_base_92m16，rst_lbus_n。
3.1.10	【规定】仿真文件命名
用于仿真测试的文件的名字与被测试模块名字一一对应，添加后缀*_tb。
3.1.11	【规定】声明所有使用的信号
模块中所有用到的信号必须在信号声明部分进行声明：如果一个信号名没做声明，Verilog 将默认定义它为一位宽的wire 变量。
3.1.12	【建议】模块之间接口信号命名
模块之间的接口信号，命名分为两个部分，第一部分表明数据方向，其中数据发出方在前，数据接收方在后，第二部分为数据名称；若某个信号从一个模块传递到多个模块，其命名应视信号的主要路径而定，在不同的子模块中尽量采用相同的名字；端口和连接端口的信号尽可能采用相同的名字。
示例：cpu_mmu_wr_req，该信号含义为CPU 模块到MMU 的写请求。
3.1.13	【建议】跨时钟域信号命名
用于跨时钟域信号传递消除亚稳态的两级寄存器，前一个寄存器输出信号命名为*_meta，第二个寄存器使用*_meta 作为输入，*_sync 作为输出。

3.2	注释和文本规范
3.2.1	【规定】文件头
每个设计文件开头应包含如下注释内容：公司名称、作者、创建时间、文件名、所属（设备、单盘、项目）、顶层模块、所需库、使用的仿真器和综合工具（运行平台和版本）、模块名称及实现功能和关键特性描述、文件创建和修改记录（包括修改版本号、修改时间、修改人名字、修改内容）。示例如下：
//***************************************************************//
// Company  			:	Fiberhome FPGA Department of Logic 
// Engineer 			:	钟永波  
// Create Date			:	2014.7.16 
// Design Name	        	:	盘名/盘号/板号/版本号（顶层模块写盘版本号）或顶层模块名称（子模块）
// Module Name		:	顶层模块名或模块名称
// Target Device		:	Artix 7 : XC7A100T-3FGG484
// Tool Version			:	ISE13.1
// Initial Version			:	
// Additional Comments	:	
// Email         		:    ybzhong@fiberhome.com.cn
// Tel           		:    (86)-27-59100284
// Description		 	:
//***************************************************************//
// Revision			:	修改版本
// Modify by			:	修改者姓名
// Modify Date			:	年/月/日（代码内部时间版本寄存器需要修改，和内部寄存器时间版本一致）
// Modify Description  	:
//***************************************************************//
// Revision			:	修改版本
// Modify by			:	修改者姓名
// Modify Date			:	年/月/日（代码内部时间版本寄存器需要修改，和内部寄存器时间版本一致）
// Modify Description 	:
//***************************************************************//

3.2.2	【规定】注释采用全中文
1.	所有的源代码块中应加入详细、清晰的注释行以增强代码的可读性和可移植性；
2.	源代码中的端口要求有准确的信号注释；
3.	源代码中的关键信号要求有准确的信号注释，例如时钟信号、复位信号、逻辑控制信号、中间变量信号。
4.	使用//进行的注释行在//后加一个空格，并以分号结束；
5.	使用/* */进行的注释，/*和*/各占用一行，并且顶头；
示例：
        // 沿检测被用于同步输入信号；
        /*
沿检测被用于同步输入信号；
*/
6.	在每节源代码（相关逻辑）之前有几行注释对该节代码加以描述，至少列出本节中描述的信号的含义，实现的功能，尽量在每个always 块之前加一段注释，增加可读性和便于调试；
7.	 修改原设计者的代码，应在修改处的注释中加入修改者的名字，修改原因，修改时间，和源代码开头的注释中修改版本相对应。
8.	在endmodule，endtask，endcase等标记一个代码块结束的关键词后面要加上一行注释说明这个代码块的名称。
示例：
//********* Frame数据处理 *********//
always @(posedge pon_clk or negedge frame_down_rst_n)	// Frame数据处理//
begin
	 if (!frame_down_rst_n)
	 	frame_data <= 64'b0;
	 else
		case ( frame_sel )
			1:		 frame_data	<= frame_data_1;
			2:	  	 frame_data	<= frame_data_2;
			3:	  	 frame_data	<= frame_data_3;
			default: frame_data	<= frame_data_0;
		endcase
end
endmodule // Frame 数据模块
9.	注释应该与代码一致，修改代码的时候一定要修改相应的注释；
10.	注释不应重复代码已表明的内容，而是简明扼要地说明代码的突出特征。
3.2.3	【规定】端口定义
1．端口定义按照功能块划分，每个功能块中按照输入、输出、双向的顺序，各个功能块之间要有空行或注释作为间隔；
2．端口信号排列要统一，一个信号只占一行，最好按输入输出及从哪个模块来到哪个模块去的关系排列，每行声明一个端口并有注释，注释在同一行；
示例：
inout    	[7:0]	data;
output    [7:0]	reg_out;
3．用下述顺序声明端口，不同类型的端口声明使用一个空行间隔；
Inputs：
.clocks
.resets
.enables
.other control signals
.data and address lines
Outputs：
.clocks
.resets
.enables
.other control signals
.data and address lines
示例：
//********* 时钟信号 *********//
		input   	clk_78m;     	//输入的78MHz全局时钟

//********* 复位信号 *********//
		input   	rst_n;   	 	//输入的全局复位信号
   	output		rst_pmc5367; 	//输出的对PMC5367的复位信号

//********* 开销处理信号 *********//
		input		[4:0]	apsi; 	//APS输入
		output	    [4:0]	apso; 	//APS输出
		output 	    aps_ctl; 		//APS输出控制
3.2.4	【规定】时延单位和精度定义
在模块端口声明之前定义时延单位和时延精度，和文件头及端口声明各有一个空行间隔，格式为：`timescale 1ns / 100ps。
3.2.5	【规定】程序中应避免出现特定数值
在设计中不要直接使用数字，作为例外，可以使用0 和1。建议采用参数定义代替直接的数字。同时，在定义常量时，如果一个常量依赖于另一个常量，建议在定义该常量时用表达式表示出这种关系。用parameter 或’define 来定义变量，禁止使用defparams。
示例：
不好的编码风格 						好的编码风格
wire [7:0] my_in_bus； 			   ‘define MY_BUS_SRIE 8
reg [7:0] my_out_bus； 			  	wire [MY_BUS_SRIE-1:0] my_in_bus；
reg  [MY_BUS_SRIE-1:0] my_out_bus；
3.2.6	【规定】独立成行
每一行语句独立成行。尽管Verilog 允许一行可以写多个语句，但每个语句独立成行可以增加可读性和可维护性。
3.2.7	【规定】缩进
1．采用制表符Tab对语句对齐和缩进，Tab键采用4个字符宽度，可在编辑器中设置。
2．同一个层次的所有语句左端对齐。
3．各种嵌套语句尤其是if...else语句，必须严格的逐层缩进对齐。每加深一层缩进一个Tab。
3.2.8	【规定】总线顺序
总线的有效位顺序定义从MSB 到LSB。
示例：data[7:0]；
3.2.9	【规定】空行
分节书写，各节之间加1 到多个空行。如每个always，initial 语句都是一节。每节基本上完成一个特定的功能，即用于描述某几个信号的产生。在每节之前有几行注释对该节代码加以描述，至少列出本节中描述的信号的含义。
3.2.10	【规定】空格
在表达式中插入空格，避免代码拥挤，包括：
1．不同变量，以及变量与符号、变量与括号之间都应当保留一个空格；
2．Verilog 关键字与其它任何字符串之间都应当保留一个空格；
3.  赋值符号两边要有空格；
4．双目运算符（逻辑运算符，算术运算符，比较运算符）的两侧各留一个空格，与变量分割开来；
5．单操作数运算符，直接位于操作数前，不适用空格（如~、|、&等）；
示例：
a  <=  b;
c  <=  a  +  b;
if (a  ==  b) then ...
a  <=  ~a  &  c;
6. 行尾不要有多余的空格。
3.2.11	【规定】语句对齐
1．	同一个层次的所有语句左端对齐；
2．	Initial、always 等语句块的关键词顶头书写，begin 关键词跟相应的end 关键词一一对齐
3.2.12	【建议】保持注释比例
使用适当的注释来解释所有的always 进程、函数、端口定义、信号含义、变量含义或信号组、变量组以及常量的意义等。注释应该放在它所注释的代码附近，要求简明扼要，只要足够说明设计意图即可，避免过于复杂，保持20%~25%的注释率。注释描述代码的功能，而不是行为。
示例：
这样的注释纯粹是废话
// 地址增加
addr = addr + 1’b1；
这样注释就好得多
//将读地址指向下一个地址单元
addr = addr + 1’b1；
3.2.13	【建议】模块区域划分
模块按照下列功能块顺序组织：
1．文件头
2．时延单位和时延精度
3．端口声明
4．参数声明
5．信号声明
6．逻辑功能
各个功能块之间要有空行或注释作为间隔，各部分声明（例如端口、信号）都添加必要注释。
3.2.14	【建议】例化
1．模块名、模块例化名统一，例化前加大写“Un_”区分，其中n 表示多次例化标识；模块例化针对功能进行相应注释；
2．使用名字相关的显式映射而禁止采用位置相关的映射；
3．输入和输出每类端口之间一个空行来提高可读性；
4．模块例化时不允许存在未连接的信号，所有未使用的模块输入必须加上确定的逻辑值，不允许输入信号出现悬空状态。
这样可以提高代码的可读性和方便debug 连线错误。
示例：
子模块名 U1_子模块名（. 端口1 （信号1），
. 端口2 （信号2），
. 端口3 （信号3），
…….
. 端口n （信号n））；
3.2.15	【建议】无效代码
单纯的无效或错误代码应删除，而不要变成注释；代码调试，版本修改过程中的代码变动则应做注释，注释内容应包含修改记录。
3.2.16	【建议】模块互联
1．顶层模块应只是内部模块间的互联（例化），尽量避免再做任何逻辑，如不能出现对reg 变量赋值等。这样做的目的是为了能更有效的综合，因为在顶层模块中出现中间逻辑，综合工具不能把子模块中的逻辑综合到最优（影响资源评估）。
2．端口连接时避免使用表达式。
3.2.17	【建议】数值分组
书写数值时每隔4 个bit 用下划线（“_”）隔开。
示例：32’h0000_0000；
3.2.18	【建议】行长度
保持每行小于80 个字符，如超出，则要换行。这样做都是为了提高代码得可读性，留出边空，方便打印，保持代码的清晰，美观和层次感。
示例：
不好的：
If ( ( my_signal1 && your_signal1 ) || ( my_signal2 && your_signal2 ) || ( my_signal3 && your_signal3 ) ) begin

好的：
If ( ( my_signal1 && your_signal1 ) ||
( my_signal2 && your_signal2 ) ||
( my_signal3 && your_signal3 ) ) begin
3.3	 设计编码原则
3.3.1	【规定】避免使用latch
避免使用产生任何latch的逻辑。产生latch 的情况有：组合逻辑中if 语句缺乏else 字句，case语句中各个条件所处理的变量不同；避免方法是：对所有输入条件都给出输出，在最终优先级的分支上使用else 语句。
3.3.2	【规定】定义完整的敏感列表
1．对于组合逻辑块，敏感列表中必须包含被always 所利用的所有信号，这通常意味着所有
出现的赋值语句右边和条件表述式中的信号，也可使用always @ *；
2．对于时序逻辑块，敏感表必须包含时钟、异步复位信号等（同步复位逻辑除外）；
3．确保敏感列表中不包含不必要信息，否则会降低仿真性能。
示例：
错误的：
always @(a or b or c)
    begin
    e = d & a & b；    /*d没有在敏感电平列表中,
						d变化时e不会立刻变化,
						直到a,b,c中某一个变化*/
    d = e || c；
    end

正确的：
always @(a or b or c or d)
    begin
    e = d & a & b；  /*d在敏感电平列表中,d变化时e立刻变化*/
    d = e || c；
    end 
3.3.3	【规定】同步化
进入FPGA的信号必须先同步，以提高系统工作频率。
3.3.4	【规定】模块输出寄存器化
对模块的时序逻辑输出加一级寄存器，通过模块端口透传信号除外。这样做使模块的输出驱动强度和下级模块的输入延迟可预测，有利于模块的寄存器平衡和管道化，同时可以提高工作频率，这对设计达到时序收敛也是极有好处的。
3.3.5	【规定】优先级
用括号来表示执行的优先级，而不是依靠操作符本身的优先顺序。
示例：x  =（a + b）* c - d；
3.3.6	【规定】根据功能选用条件语句
有优先级的建议使用if 语句；case 语句用于描述平行逻辑，即须确保不同的条件是互斥的。
1．在Verilog语言中的case语句对应一个单级的多选电路， if-else/ if-else语句对应于一个优先编码的多级组合选择电路；
2．如果你的设计中没有优先级的要求，最好多用case语句少用if-else语句，if-else的嵌套不能超过五级。
3.3.7	【规定】总线对齐
赋值或者条件判断时要注明比特宽度，注意表达式的位宽匹配。常数赋值也相应匹配位宽。
示例：reg [15:0] data_out； data_out <= 16’hxxxx；
3.3.8	【规定】禁止组合环
禁止出现组合逻辑环（就是没有寄存器的反馈环路。这种结构在仿真和综合的时候都会有问题）组合环非常难以测试，因为它很难设成一个已知的状态。
示例：a = b；b = c；c = a；
3.3.9	【规定】阻塞赋值和非阻塞赋值
1．时序逻辑使用非阻塞赋值；
2．组合逻辑使用阻塞赋值；
3．同一个always 模块不容许同时有阻塞赋值和非阻塞赋值；
4．禁止在不同的always模块 中对同一变量赋值。
3.3.10	【规定】禁止使用内部三态
禁止使用内部三态电路，建议用多路选择电路代替内部三态电路。
3.3.11	【规定】禁止使用任务
RTL 级代码禁止使用task，原因是task 根据调用的情况不同，可综合成组合逻辑电路，也可综合成时序逻辑电路，增加了逻辑电路的歧义性。（仿真调试代码除外）
3.3.12	【规定】CASE 语句
1．case 语句中如果不需要优先级，那么必须确保不同的条件是互斥的；相同结果的条件支应该合并；
2．case 语句必须覆盖所有的条件，不管是指定条件还是用default 语句。如果可能的话在default 语句中把x 值赋给输出。
3.3.13	【规定】数值指定宽度
对于数值一律指定进制和宽度，否则默认数值宽度是32bit，会导致比预想的大得多的算术单元。
3.3.14	【规定】显式表明条件
显式表明判决条件。避免操作数位宽不匹配，高低电平有效不一致等引起的判决错误。
示例：
不好的
if (~en & signal_ctl )
...
好的
if ( signal_ctl == 1'b1 && en == 1’b0 )
...
3.3.15	【规定】时钟使用
1．时钟信号选用全局时钟缓冲器BUFG；
2．禁止使用门控时钟；
3．禁止使用内部逻辑产生时钟信号；
4．禁止用时钟或复位信号作数据或使能信号，同时禁止用数据信号作为时钟或复位信号；
5．时钟信号必须连接到全局时钟管脚上，禁止用计数器分频后的信号做其它模块的时钟，而要改成用户时钟使能的方式，否则这种时钟满天飞的方式对设计的可靠性极为不利，也大大增加了静态时序分析的复杂性。
3.3.16	【规定】复位信号
1. 复位信号采用异步低电平有效信号，外部复位信号连接到芯片全局复位输入端（这些管脚提供较低的抖动）；复位使初始状态可预测，防止出现禁用状态；为避免释放复位状态时和时钟冲突，复位信号需要在顶层连接前进行异步复位同步化操作。
2. 确保所有寄存器只被简单的复位信号控制，禁止内部产生的条件复位信号，模块内所有寄存器应在同一时间内被复位。
3. 复位的条件表达式及命名要和always 敏感列表中的描述相统一，并且内部逻辑一定要使用异步复位。所有的复位必须低有效。
3.3.17	【建议】区分关键路径
关键路径和非关键路径逻辑放在不同模块。可能成为关键路径的电路有：比较器，多路选择器，分布式RAM，乘法器，加法器等；尤其是比较大的情况，建议做方案时针对这些电路进行速度评估，决定是否要pipeline。
3.3.18	【建议】保持一个模块一个时钟
尽可能在整个设计中只使用一个主时钟，同时只使用同一个时钟沿，主时钟走全局时钟网络；跨时钟域信号使用两级reg 消除亚稳态（多比特位宽信号利用格雷码转换）。在多时钟域的设计中涉及到跨时钟域的设计中最好有专门一个模块做时钟域的隔离。这样可以让综合器综合出更优的结果。
3.3.19	【建议】避免例化具体门级电路
在设计中避免实例化具体的门级电路。门级电路可读性差，且难于理解和维护，如果使用特定工艺的门电路，设计将变得不可移植；如果必须实例化门电路，建议采用独立于工艺库的门电路。
3.3.20	【建议】使用函数
如果同一段代码需要重复多次，尽可能使用函数，以避免冗长的逻辑和子表达式；如果有可能，可以将函数通用化，以使得它可以复用。注意，内部函数的定义一般要添加注释，这样可以提高代码的可读性。
3.3.21	【建议】避免振荡器
避免使用负延触发的双稳态多谐振荡器（flip flop）。
3.3.22	【建议】插入单位延迟
采用"intra-assignment timing delay"（在非阻塞赋值前人为加入一个很小单位的延时）。这种描述的好处之一是：它简单模拟了赋值过程寄存器内部的clock-to-output 的延时，在做行为级功能仿真的时候，也可以发现一些由于寄存器固有延迟造成的时序和功能问题。
该单位延迟定义为parameter，名字为U_DLY（仿真用的单位延迟）；
示例：data_a <= #U_DLY data_in；
3.3.23	【建议】变量赋值的唯一性
不要在一个always 块里给多个变量赋值。如果将一组条件相同的变量写在一个always块中有更利于可读性的提高和功能的实现时候，可有例外情况，但需尽量多加注释，增加可读性。
3.3.24	【建议】参数传递
需要传递参数的模块，在多次例化的时候统一都传递参数，不要例化同一个模块，有的传参数，有的不传。
3.4	状态机设计规范
3.4.1	【规则】状态定义
状态定义用parameter 定义，而不使用`define 宏定义的方式。
`define 宏定义在编译时自动替换整个设计中所定义的宏，而parameter 仅仅定义模块内部的参数，定义的参数不会与模块外的其他状态机混淆。
3.4.2	【规则】保持层次
使有限状态机FSM 保持在层次中的自己所在的那一级，不允许综合工具在输出和下一个状态译码逻辑之间共享资源。
3.4.3	【规则】处理所有状态
必须包括对所有状态都处理，不能出现无法处理的状态使状态机失控（逻辑会挂死），即禁止缺损default状态。
3.4.4	【规则】状态机编码方式
常用的状态机编码方式有三种：顺序码，独热码（one-hot），格雷码。
顺序码：顺序码是初学设计的人最常用的编码。这种编码方式的特点是简单，符合人们通常的计数规则。比如，IDLE=0，WAIT=1，HOLD=2，……。
格雷码：它的特点是相邻的两个数只有一位变化。比如，IDLE=4'B0001，WAIT=4'B0011，HOLD=4'B0010，……。采用格雷码的时候，如果数据是顺序变化的，那么同一时刻总线上只有一位在翻转，数据变化速度快，也能最大程度地避免bus内的干扰，
独热码：独热码的特点是每个状态中只有一位有效。比如，IDLE=4'B0001，WAIT=4'B0010，HOLD=4'B0100，……。采用这样的编码方式，需要更多的寄存器来存储状态，在一定程度上会增加设计的面积。但是它需要的译码电路最简单，译码速度快，而且能避免译码时引起毛刺，因此在一些大型电路中使用的较多。
采用三种编码方式实现状态机时，顺序码和格雷码采用较少的触发器，较多的组合逻辑，独热码采用较多的触发器，较少的逻辑。对于CPLD多用格雷码实现，对于FPGA多用独热码实现；对于小型设计（一般2-3位编码的状态机）使用顺序码和格雷码好些，可以在满足性能的条件下，将面积做到最优，对于大型设计使用独热码好些，减小了大的组合逻辑，提升了状态机性能。
下图是One-hot编码和二进制编码的对照：（绿色为推荐实现方式）
 
3.4.5	【规则】三段式状态机写法
状态机要写成3 段式的（这是最标准的写法），第一段产生sequential 的状态寄存器，第二段产生下一状态的组合逻辑，第三段为输出信号逻辑。
示例：
      				      always @(posedge clk or negedge rst_n)（第一段）
	             ...
                current_state <= next_state;
	             ...
       always @ (current_state ...)（第二段）
	              ...
                   case(current_state)
    	        ...
                   s1: if ...
                        next_state = s2;
              ...
          always @(posedge clk or negedge rst_n)（第三段）
	              ...
                else					
                  case(current_state)
                      s1:	a <= 1'b0; 
	          			                   s2:	b <= 1'b1;
                         default:				
                         ...
3.4.6	【建议】状态机完备性
一个完备的状态机（健壮性强）应该具备初始化（reset）状态和默认（default）状态。
3.5	目录结构和工具设定
3.5.1	【规则】重视告警（warning）
所有RTL 级代码必须通过编译和综合。必须没有错误，必须重视工具产生的警告信息，确认每条警告含义，避免因此使设计的实现产生隐患。尽量优化代码消除所有warning。
3.5.2	【建议】组合逻辑限于本模块
组合电路设计中应当没有层次，每个模块输出尽量采用寄存器输出形式，做到这一点，对约束比较方便。同一条路径上的组合逻辑尽可能打散，这对综合非常有利，可以方便的达到速度面积双赢的目的；模块按功能合理划分，模块大小适中，一般为2000 门左右，具体按照综合工具性能确定。
3.5.3	【建议】模块大小划分
通常会推荐将模块划分得越小越好，事实上要从实际的设计目标面积和时序要求出发，好的时序规划和合适的约束条件要比电路的大小对综合时间的影响要大，要依照设计的目标来划分模块；最好在设计阶段就做好时序规划，通过综合的约束scripts 来满足时序规划，这样就能获得既满足性能的结果，又使得综合时间最省；从代码设计角度讲，500~5000 行的长度是合适的。
3.5.4	【建议】资源共享
资源共享的应用限制在同一个module 里；尽可能将critical path 上所有相关逻辑放在同一个module 里。critical path 所在的module 与其他module 分别综合，对critical path采用速度优先的综合策略，对其它module 采用面积优先的综合策略。
这样综合工具才能最大限度地发挥其资源共享综合作用，发挥其最佳综合效果。
利用资源共享还便于减少逻辑模块的数量。
示例：
没有资源共享共用了4 个加法器 		  		利用资源共享只用2 个选择器和1 个加法器
if ( sel == 1’b1 )  						if ( sel == 1’b1 ) 				
                                      		begin                   
sum <= a + b ; 									temp1 <= a;
else 											temp2 <= b;
sum <= c + d ;								end						
											else
											begin					
												temp1 <= c;
												temp2 <= d;	
											end						
sum <= temp1 + temp2;
3.6	附录：编程惯例
（1）	所有综合工具都支持的结构：
always，assign，begin，end，case，wire，tri，aupply0，supply1，reg，integer，default，for，function，and，nand，or，nor，xor，xnor，buf，not，bufif0，bufif1，notif0，notif1，if，inout，input，instantitation，module，negedge，posedge，operators，output，parameter。
（2）	所有综合工具都不支持的结构：
time，defparam，$finish，fork，join，initial，delays，UDP，wait。
（3）	有些工具支持有些工具不支持的结构：
casez，wand，triand，wor，trior，real，disable，forever，arrays，memories，repeat，task，while，generate。
（4）	在进行可综合设计时，要保证Verilog HDL的可综合性和提高综合性能，应注意下面要点：
1）	不使用初始化语句，不使用初始化赋值。
2）	不使用循环次数不确定的循环语句，如forever等。
3）	不使用用户自定义原语（UDP元件）。
4）	尽量使用同步方式设计电路。
5）	除非是关键路径的设计，一般不采用调用门级元件来描述设计的方法，建议采用行为语句来完成设计。
6）	所有的内部寄存器都应该能够被复位，在使用FPGA实现设计时，应尽量使用器件的全局复位端作为系统总的复位。
7）	对时序逻辑描述和建模，应尽量使用非阻塞赋值方式。对组合逻辑 描述和建模，既可以用阻塞赋值，也可以用非阻塞赋值。但在同一个过程块中，最好不要同时用阻塞赋值和非阻塞赋值。
8）	如果在组合逻辑块中不打算把变量推导成锁存器，那么必须在if语句或case语句的所有条件分支中都对变量明确地赋值。
9）	模块内部避免混合使用上升沿和下降沿触发的触发器。
3.7	附录：代码范例
下面的推荐写法可提高源代码综合后电路实现的稳定性，还可减少仿真需要的CPU资源和时间。 
3.8	 case 语句和 if/else语句
建议尽可能在设计中使用case代替if/else，下图是一个完成8路选择器的代码对照（绿色为推荐实现方式）：
 
另一个可参考的八选一组合逻辑电路的代码写法，综合结果和always块的写法是一样的。
assign clk25m_line1 =
    (div1_con == 4'b0000)? rx_clk_cout[0] : 
    (div1_con == 4'b0001)? rx_clk_cout[1] : 
    (div1_con == 4'b0010)? rx_clk_cout[2] : 
    (div1_con == 4'b0011)? rx_clk_cout[3] : 
    (div1_con == 4'b0100)? rx_clk_cout[4] : 
    (div1_con == 4'b0101)? rx_clk_cout[5] : 
    (div1_con == 4'b0110)? rx_clk_cout[6] : 
    (div1_con == 4'b0111)? rx_clk_cout[7] : 
                           1'bz;
3.9	 begin-end 语句
 
3.10	 always 语句
（1）	用always过程块描述组合逻辑，应在敏感信号列表中列出所有的输入信号。每个组合逻辑always块中的触发条件和赋值表达式的右边的信号都是敏感信号。敏感信号不写全也是可以综合通过的。推荐直接在敏感表中写“*”比较方便。
示例：always @ （*）
（2）	建议一个always block里面只处理一个信号。下面给出一个4位移位寄存器的代码实现例子（绿色为推荐实现方式）：
 
3.11	 blocking语句和nonblocking语句
建议在设计中遵循以下原则：
（1）	时序逻辑设计使用nonblocking语句；举例
（2）	设计锁存器时使用nonblocking语句；
（3）	一个always block中只有组合逻辑使用blocking语句；
（4）	一个always block中既有组合逻辑又有时序逻辑使用nonblocking语句；
（5）	不要在一个always block中同时使用blocking语句和nonblocking语句；
（6）	一个信号只能在一个always block中被赋值；
 
用阻塞赋值代替了非阻塞赋值。这样做，既保证了仿真时经一次数据传递输出y的值是正确的，又提高了仿真效率。另外，在赋值表达式右端参与赋值的信号都必须在always@（敏感电平列表）中列出避免产生一个透明锁存器。
3.12	内部门控时钟可以用同步置数替代
如果确实要使用内部时钟、门控时钟或内部的复位信号，将它们放在顶层。将这些信号的产生放在顶层的一个独立模块，这样所有的子模块分别使用单一的时钟和复位信号。一般情况下内部门控时钟可以用同步置数替代。例如：（绿色为推荐实现方式）
 
3.13	组合逻辑RTL代码的并行结构
组合逻辑RTL代码尽量采用并行结构，它可以降低寄存器间组合路径的延迟，因此在完成相同功能的前提下应该尽量使用并行逻辑。而代码风格与综合所获得的RTL结构有着密切的关系，并行结构的选择可有效改善耗时较多的运算模块。
对比图1与图2的RTL电路，同是消耗3个加法器资源的情况下，图1的延迟小，时序性能有很大优化。
 
图1 表达式z=(a+b)+(c+d)的RTL电路

 
图2 表达式z=a+b+c+d的RTL电路

3.14	 附录：常用单词缩写对应表
表1 常用单词缩写对照表
全称	缩写	中文含义
acknowledge	ack	应答
adress	addr	地址
arbiter	arb	仲裁
check	chk	校验，如CRC校验
clock	clk	时钟
config	cfg	Configuration，配置
control	ctl	控制
count	cnt	计数
data in	din	数据输入
data out	dout	数据输出
decode	de	译码
decrease	dec	减一
delay	dly	延时
disable	dis	不使能
error	err	错误（指示）
enable	en	使能
frame	frm	帧
generate	gen	生成，如生成帧
grant	gnt	申请通过
increase	inc	加一
input	in	输入
length	len	（帧、包）长
memory	mem	存储
nmport	nm	网管相关
output	out	输出
packet	pkt	数据包
priority	pri	优先级
pointer	ptr	指针
read enable	ren	读使能
read	rd	读（操作）
ready	rdy	应答信号或准备好
receive	rx	（数据）接收
request	req	（服务、仲裁）请求
reset	rst	复位
segment	seg	划分、分段
source	scr	源（端口）
ststistics	stat	统计
switcher	sf	交换机
timer	tmr	定时器
temporary	tmp	临时
transmit	tx	发送（帧数据）
valid	vld	有效、校验正确
write enable	wen	写使能
write	wr	写（操作）
bmu扣板接口信号（cpu类接口同此）
bmu addr	addr_bmu[31:0]	32位地址总线
bmu data	data_bmu[31:0]	32位数据总线
interruption request	irq6_bmu	第n个中断请求（示例为6）
bmu chip select	cs3_bmu	第n个片选信号（示例为3）


